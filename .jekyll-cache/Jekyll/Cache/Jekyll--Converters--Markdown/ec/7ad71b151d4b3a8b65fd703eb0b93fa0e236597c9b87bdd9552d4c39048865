I"≈<p>The tragic Titanic shipwreck, documented in countless books and movies, has made its way into the Machine Learning world via the Kaggle challenge: <a href="https://www.kaggle.com/c/titanic">Titanic - learning from disaster</a>. In this challenge the goal is to predict which passengers survive based on metadata like sex, name and ticket price.</p>

<p>The Titanic competition, with almost 16000 teams, is the <a href="https://dataaspirant.com/most-popular-kaggle-competition-solutions/">most popular on all of Kaggle</a>. The competition is perpetually open and is part of the ‚Äúgetting started‚Äù suite. Kaggle archives any submission older than 2 months, but even so there are over 15000 submissions as of today. There is also a wild amount of discussions and how-tos. A few worth looking at are: <a href="https://www.kaggle.com/carlmcbrideellis/titanic-leaderboard-a-score-0-8-is-great">a score of 0.8 is great</a> and the more comprehensive <a href="https://www.kaggle.com/pliptor/how-am-i-doing-with-my-score">how am I doing with my score</a>. The current top-score, as far as I can tell, is 85% by veteran Kaggle competitor <a href="https://www.kaggle.com/cdeotte/titanic-wcg-xgboost-0-84688">Chris Deotte</a>.</p>

<p>In this post we look at a new approach to solving the Titanic dataset ‚Äì render each row as a string and use a <a href="https://arxiv.org/abs/1706.03762">Transformer</a> to encode the strings into a feature vector. This eliminates tedious feature engineering required using a ‚Äústandard‚Äù scikit-learn / pandas workflow, and as we shall see, performs in the top 3% on the Kaggle leaderboard!</p>

<h2 id="data">Data</h2>

<p>Let‚Äôs take a quick look at the data before we dive in. The first three entries in the training data look like this.</p>

<table>
  <thead>
    <tr>
      <th>Survived</th>
      <th>Pclass</th>
      <th>Name</th>
      <th>Sex</th>
      <th>Age</th>
      <th>SibSp</th>
      <th>Parch</th>
      <th>Ticket</th>
      <th>Fare</th>
      <th>Cabin</th>
      <th>Embarked</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>3</td>
      <td>Braund, Mr. Owen Harris</td>
      <td>male</td>
      <td>22</td>
      <td>1</td>
      <td>0</td>
      <td>A/5 21171</td>
      <td>7.25</td>
      <td>¬†</td>
      <td>S</td>
    </tr>
    <tr>
      <td>1</td>
      <td>1</td>
      <td>Cumings, Mrs. John Bradley</td>
      <td>female</td>
      <td>38</td>
      <td>1</td>
      <td>0</td>
      <td>PC 17599</td>
      <td>71.2833</td>
      <td>C85</td>
      <td>C</td>
    </tr>
    <tr>
      <td>1</td>
      <td>3</td>
      <td>Heikkinen, Miss. Laina</td>
      <td>female</td>
      <td>26</td>
      <td>0</td>
      <td>0</td>
      <td>STON/O2. 3101282</td>
      <td>7.925</td>
      <td>¬†</td>
      <td>S</td>
    </tr>
  </tbody>
</table>

<p>‚ÄúSibSp‚Äù refers to the number of siblings and spouses and ‚ÄúParch‚Äù the number of parents. Otherwise, the column names speak for themselves. For more details refer to the excellent Kaggle <a href="https://www.kaggle.com/c/titanic/data">data explorer</a>.</p>

<h2 id="transformers">Transformers</h2>

<p>A Transformer is a type of neural network that dominates the modern Natural Language Processing field. They are even starting to challenge the convolutional neural network for image processing. If you are not familiar with them, I recommend <a href="https://jalammar.github.io/illustrated-transformer/">the illustrated transformer</a> by Jay Alammar.</p>

<p>Here we use the excellent Huggingface library to load up a pre-trained Transformer and use it as a feature extractor. Once we have the feature vector we train a XGBoost classifier with standard settings and that is pretty much it. The core feature extraction code looks like this:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">TransformerExtractor</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_name</span><span class="o">=</span><span class="s">"distilbert-base-uncased"</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">tokenizer</span> <span class="o">=</span> <span class="n">AutoTokenizer</span><span class="p">.</span><span class="n">from_pretrained</span><span class="p">(</span><span class="n">model_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">AutoModel</span><span class="p">.</span><span class="n">from_pretrained</span><span class="p">(</span><span class="n">model_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">extract</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">texts</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>
        <span class="n">feats</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">texts</span><span class="p">),</span> <span class="mi">768</span><span class="p">),</span> <span class="n">np</span><span class="p">.</span><span class="n">float16</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">itt</span><span class="p">,</span> <span class="n">text</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tqdm</span><span class="p">(</span><span class="n">texts</span><span class="p">)):</span>
            <span class="n">tokenized_text</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">tokenizer</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">return_tensors</span><span class="o">=</span><span class="s">"pt"</span><span class="p">)</span>
            <span class="n">model_output</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">model</span><span class="p">(</span><span class="o">**</span><span class="n">tokenized_text</span><span class="p">)[</span><span class="mi">0</span><span class="p">].</span><span class="n">detach</span><span class="p">().</span><span class="n">cpu</span><span class="p">().</span><span class="n">numpy</span><span class="p">()</span>
            <span class="n">feats</span><span class="p">[</span><span class="n">itt</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">model_output</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">).</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">feats</span>
</code></pre></div></div>

<p>The only design choice here is how to join the row entries into a string. In this submission I use the simplest option possible: concatenating the entries together. This achieves a score of <code class="language-plaintext highlighter-rouge">0.80143</code> on the public benchmark which currently ranks 454 out of 14855 (top 3%). Not bad considering the simplicity and flexibility of the approach! I tried adding the column headers also but it didn‚Äôt boost the score any further.</p>

<p>Code is available in a <a href="https://www.kaggle.com/oscarbeijbom/titanictransformers">Kaggle notebook</a>. That is pretty much it, happy coding!</p>
:ET